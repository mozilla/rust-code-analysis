// Code generated; DO NOT EDIT.

#[derive(Clone, Debug, PartialEq, FromPrimitive)]
pub enum Typescript {
    End = 0,
    Identifier = 1,
    HashBangLine = 2,
    Export = 3,
    STAR = 4,
    Default = 5,
    EQ = 6,
    As = 7,
    Namespace = 8,
    LBRACE = 9,
    COMMA = 10,
    RBRACE = 11,
    Type2 = 12,
    Typeof = 13,
    Import2 = 14,
    From = 15,
    Var = 16,
    Let = 17,
    Const = 18,
    BANG = 19,
    Else = 20,
    If = 21,
    Switch = 22,
    For = 23,
    LPAREN = 24,
    RPAREN = 25,
    Await = 26,
    In = 27,
    Of = 28,
    While = 29,
    Do = 30,
    Try = 31,
    With = 32,
    Break = 33,
    Continue = 34,
    Debugger = 35,
    Return = 36,
    Throw = 37,
    SEMI = 38,
    COLON = 39,
    Case = 40,
    Catch = 41,
    Finally = 42,
    Yield = 43,
    LBRACK = 44,
    RBRACK = 45,
    LT = 46,
    GT = 47,
    SLASH = 48,
    DOT = 49,
    Class2 = 50,
    Async = 51,
    Function2 = 52,
    EQGT = 53,
    QMARKDOT = 54,
    New = 55,
    PLUSEQ = 56,
    DASHEQ = 57,
    STAREQ = 58,
    SLASHEQ = 59,
    PERCENTEQ = 60,
    CARETEQ = 61,
    AMPEQ = 62,
    PIPEEQ = 63,
    GTGTEQ = 64,
    GTGTGTEQ = 65,
    LTLTEQ = 66,
    STARSTAREQ = 67,
    AMPAMPEQ = 68,
    PIPEPIPEEQ = 69,
    QMARKQMARKEQ = 70,
    DOTDOTDOT = 71,
    QMARK = 72,
    AMPAMP = 73,
    PIPEPIPE = 74,
    GTGT = 75,
    GTGTGT = 76,
    LTLT = 77,
    AMP = 78,
    CARET = 79,
    PIPE = 80,
    PLUS = 81,
    DASH = 82,
    PERCENT = 83,
    STARSTAR = 84,
    LTEQ = 85,
    EQEQ = 86,
    EQEQEQ = 87,
    BANGEQ = 88,
    BANGEQEQ = 89,
    GTEQ = 90,
    QMARKQMARK = 91,
    Instanceof = 92,
    TILDE = 93,
    Void = 94,
    Delete = 95,
    PLUSPLUS = 96,
    DASHDASH = 97,
    DQUOTE = 98,
    StringToken1 = 99,
    SQUOTE = 100,
    StringToken2 = 101,
    EscapeSequence = 102,
    Comment = 103,
    BQUOTE = 104,
    DOLLARLBRACE = 105,
    SLASH2 = 106,
    RegexPattern = 107,
    RegexFlags = 108,
    Number = 109,
    Target = 110,
    This = 111,
    Super = 112,
    True = 113,
    False = 114,
    Null = 115,
    Undefined = 116,
    AT = 117,
    Declare = 118,
    Static = 119,
    Readonly = 120,
    Abstract = 121,
    Get = 122,
    Set = 123,
    Public = 124,
    Private = 125,
    Protected = 126,
    Module3 = 127,
    Any = 128,
    Number2 = 129,
    Boolean = 130,
    String2 = 131,
    Symbol = 132,
    Require = 133,
    Implements = 134,
    Global = 135,
    Interface = 136,
    Extends = 137,
    Enum = 138,
    DASHQMARKCOLON = 139,
    QMARKCOLON = 140,
    Asserts2 = 141,
    Infer = 142,
    Is = 143,
    Keyof = 144,
    LBRACEPIPE = 145,
    PIPERBRACE = 146,
    AutomaticSemicolon = 147,
    TemplateChars = 148,
    FunctionSignatureAutomaticSemicolon = 149,
    Program = 150,
    ExportStatement = 151,
    ExportClause = 152,
    ExportSpecifier = 153,
    Declaration = 154,
    Import = 155,
    ImportStatement = 156,
    ImportClause = 157,
    FromClause = 158,
    NamespaceImport = 159,
    NamedImports = 160,
    ExpressionStatement = 161,
    VariableDeclaration = 162,
    LexicalDeclaration = 163,
    VariableDeclarator = 164,
    StatementBlock = 165,
    ElseClause = 166,
    IfStatement = 167,
    SwitchStatement = 168,
    ForStatement = 169,
    ForInStatement = 170,
    ForHeader = 171,
    WhileStatement = 172,
    DoStatement = 173,
    TryStatement = 174,
    WithStatement = 175,
    BreakStatement = 176,
    ContinueStatement = 177,
    DebuggerStatement = 178,
    ReturnStatement = 179,
    ThrowStatement = 180,
    EmptyStatement = 181,
    LabeledStatement = 182,
    SwitchBody = 183,
    SwitchCase = 184,
    SwitchDefault = 185,
    CatchClause = 186,
    FinallyClause = 187,
    ParenthesizedExpression = 188,
    Expression = 189,
    PrimaryExpression = 190,
    YieldExpression = 191,
    Object = 192,
    ObjectPattern = 193,
    AssignmentPattern = 194,
    ObjectAssignmentPattern = 195,
    Array = 196,
    ArrayPattern = 197,
    NestedIdentifier = 198,
    Class = 199,
    ClassDeclaration = 200,
    ClassHeritage = 201,
    Function = 202,
    FunctionDeclaration = 203,
    GeneratorFunction = 204,
    GeneratorFunctionDeclaration = 205,
    ArrowFunction = 206,
    CallSignature = 207,
    FormalParameter = 208,
    CallExpression = 209,
    NewExpression = 210,
    AwaitExpression = 211,
    MemberExpression = 212,
    SubscriptExpression = 213,
    AssignmentExpression = 214,
    AugmentedAssignmentLhs = 215,
    AugmentedAssignmentExpression = 216,
    Initializer = 217,
    DestructuringPattern = 218,
    SpreadElement = 219,
    TernaryExpression = 220,
    BinaryExpression = 221,
    UnaryExpression = 222,
    UpdateExpression = 223,
    SequenceExpression = 224,
    String = 225,
    TemplateString = 226,
    TemplateSubstitution = 227,
    Regex = 228,
    MetaProperty = 229,
    Arguments = 230,
    Decorator = 231,
    MemberExpression2 = 232,
    CallExpression2 = 233,
    ClassBody = 234,
    PublicFieldDefinition = 235,
    FormalParameters = 236,
    Pattern = 237,
    RestPattern = 238,
    MethodDefinition = 239,
    Pair = 240,
    PairPattern = 241,
    PropertyName = 242,
    ComputedPropertyName = 243,
    NonNullExpression = 244,
    MethodSignature = 245,
    AbstractMethodSignature = 246,
    FunctionSignature = 247,
    TypeAssertion = 248,
    AsExpression = 249,
    ImportRequireClause = 250,
    ImplementsClause = 251,
    AmbientDeclaration = 252,
    AbstractClassDeclaration = 253,
    Module = 254,
    InternalModule = 255,
    Module2 = 256,
    ImportAlias = 257,
    NestedTypeIdentifier = 258,
    InterfaceDeclaration = 259,
    ExtendsClause = 260,
    EnumDeclaration = 261,
    EnumBody = 262,
    EnumAssignment = 263,
    TypeAliasDeclaration = 264,
    AccessibilityModifier = 265,
    RequiredParameter = 266,
    OptionalParameter = 267,
    ParameterName = 268,
    OmittingTypeAnnotation = 269,
    OptingTypeAnnotation = 270,
    TypeAnnotation = 271,
    Asserts = 272,
    Type = 273,
    RequiredParameter2 = 274,
    OptionalParameter2 = 275,
    OptionalType = 276,
    RestType = 277,
    TupleTypeMember = 278,
    ConstructorType = 279,
    PrimaryType = 280,
    InferType = 281,
    ConditionalType = 282,
    GenericType = 283,
    TypePredicate = 284,
    TypePredicateAnnotation = 285,
    TypeQuery = 286,
    IndexTypeQuery = 287,
    LookupType = 288,
    MappedTypeClause = 289,
    LiteralType = 290,
    UnaryExpression2 = 291,
    ExistentialType = 292,
    FlowMaybeType = 293,
    ParenthesizedType = 294,
    PredefinedType = 295,
    TypeArguments = 296,
    ObjectType = 297,
    CallSignature2 = 298,
    PropertySignature = 299,
    TypeParameters = 300,
    TypeParameter = 301,
    DefaultType = 302,
    Constraint = 303,
    ConstructSignature = 304,
    IndexSignature = 305,
    ArrayType = 306,
    TupleType = 307,
    ReadonlyType = 308,
    UnionType = 309,
    IntersectionType = 310,
    FunctionType = 311,
    ProgramRepeat1 = 312,
    ExportStatementRepeat1 = 313,
    ExportClauseRepeat1 = 314,
    NamedImportsRepeat1 = 315,
    VariableDeclarationRepeat1 = 316,
    SwitchBodyRepeat1 = 317,
    ObjectRepeat1 = 318,
    ObjectPatternRepeat1 = 319,
    ArrayRepeat1 = 320,
    ArrayPatternRepeat1 = 321,
    StringRepeat1 = 322,
    StringRepeat2 = 323,
    TemplateStringRepeat1 = 324,
    ClassBodyRepeat1 = 325,
    FormalParametersRepeat1 = 326,
    ImplementsClauseRepeat1 = 327,
    ExtendsClauseRepeat1 = 328,
    EnumBodyRepeat1 = 329,
    ObjectTypeRepeat1 = 330,
    TypeParametersRepeat1 = 331,
    TupleTypeRepeat1 = 332,
    ImportSpecifier = 333,
    PropertyIdentifier = 334,
    ShorthandPropertyIdentifier = 335,
    ShorthandPropertyIdentifierPattern = 336,
    StatementIdentifier = 337,
    TypeIdentifier = 338,
    Error = 339,
}

impl std::fmt::Display for Typescript {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[allow(clippy::unreadable_literal)]
static KEYS: phf::Map<&'static str, &'static str> = ::phf::Map {
    key: 3213172566270843353,
    disps: ::phf::Slice::Static(&[
        (0, 2),
        (1, 177),
        (2, 97),
        (1, 43),
        (1, 1),
        (0, 0),
        (0, 90),
        (1, 109),
        (0, 28),
        (0, 3),
        (1, 64),
        (0, 7),
        (0, 49),
        (0, 5),
        (0, 33),
        (0, 8),
        (0, 33),
        (0, 198),
        (0, 0),
        (2, 84),
        (0, 91),
        (0, 4),
        (0, 13),
        (0, 34),
        (0, 233),
        (0, 254),
        (0, 47),
        (0, 238),
        (3, 302),
        (8, 337),
        (0, 3),
        (0, 241),
        (0, 2),
        (0, 1),
        (1, 318),
        (1, 97),
        (0, 63),
        (5, 183),
        (0, 7),
        (0, 59),
        (0, 27),
        (3, 308),
        (2, 115),
        (2, 266),
        (0, 1),
        (1, 189),
        (0, 0),
        (5, 236),
        (0, 204),
        (0, 46),
        (1, 308),
        (0, 11),
        (25, 147),
        (0, 28),
        (0, 0),
        (3, 101),
        (17, 165),
        (32, 269),
        (0, 219),
        (0, 160),
        (0, 202),
        (2, 143),
        (0, 0),
        (12, 286),
        (0, 63),
        (0, 23),
        (0, 4),
        (5, 291),
    ]),
    entries: ::phf::Slice::Static(&[
        ("LiteralType", "literal_type"),
        ("HashBangLine", "hash_bang_line"),
        ("TypeIdentifier", "type_identifier"),
        ("SwitchBody", "switch_body"),
        ("Var", "var"),
        ("Any", "any"),
        ("COLON", ":"),
        ("SwitchBodyRepeat1", "switch_body_repeat1"),
        ("SLASHEQ", "/="),
        ("SLASH", "/"),
        ("ConditionalType", "conditional_type"),
        ("ArrayType", "array_type"),
        ("Finally", "finally"),
        ("Number", "number"),
        ("FromClause", "_from_clause"),
        ("OptingTypeAnnotation", "opting_type_annotation"),
        ("Pattern", "pattern"),
        ("ParameterName", "_parameter_name"),
        ("Undefined", "undefined"),
        ("Asserts2", "asserts"),
        ("LBRACK", "["),
        ("SubscriptExpression", "subscript_expression"),
        ("UpdateExpression", "update_expression"),
        ("Initializer", "_initializer"),
        ("TypeAliasDeclaration", "type_alias_declaration"),
        ("Case", "case"),
        ("Async", "async"),
        ("Interface", "interface"),
        ("AssignmentExpression", "assignment_expression"),
        ("NewExpression", "new_expression"),
        ("ExportClause", "export_clause"),
        ("TypeParametersRepeat1", "type_parameters_repeat1"),
        ("ParenthesizedType", "parenthesized_type"),
        ("QMARKQMARKEQ", "??="),
        ("CatchClause", "catch_clause"),
        ("GTGT", ">>"),
        ("AccessibilityModifier", "accessibility_modifier"),
        ("True", "true"),
        ("While", "while"),
        ("DASHEQ", "-="),
        ("Break", "break"),
        ("FunctionSignature", "function_signature"),
        ("BinaryExpression", "binary_expression"),
        ("DASH", "-"),
        ("ExportStatement", "export_statement"),
        ("Regex", "regex"),
        ("Continue", "continue"),
        ("EQGT", "=>"),
        ("IndexTypeQuery", "index_type_query"),
        ("FormalParameters", "formal_parameters"),
        ("FinallyClause", "finally_clause"),
        ("NamedImportsRepeat1", "named_imports_repeat1"),
        ("EnumDeclaration", "enum_declaration"),
        ("Expression", "expression"),
        ("AssignmentPattern", "assignment_pattern"),
        ("Export", "export"),
        ("PLUSPLUS", "++"),
        ("MemberExpression", "member_expression"),
        ("RegexPattern", "regex_pattern"),
        ("String", "string"),
        ("PropertySignature", "property_signature"),
        ("Comment", "comment"),
        ("Readonly", "readonly"),
        ("ImportStatement", "import_statement"),
        ("StringRepeat1", "string_repeat1"),
        ("RPAREN", ")"),
        ("TypePredicate", "type_predicate"),
        ("Let", "let"),
        ("ParenthesizedExpression", "parenthesized_expression"),
        ("GT", ">"),
        ("ProgramRepeat1", "program_repeat1"),
        ("ClassDeclaration", "class_declaration"),
        ("LBRACEPIPE", "{|"),
        ("TypeAssertion", "type_assertion"),
        ("QMARKDOT", "?."),
        ("Keyof", "keyof"),
        ("UnionType", "union_type"),
        ("ExpressionStatement", "expression_statement"),
        ("CallExpression", "call_expression"),
        ("MethodSignature", "method_signature"),
        ("AwaitExpression", "await_expression"),
        ("OptionalParameter", "optional_parameter"),
        ("Decorator", "decorator"),
        ("Set", "set"),
        ("ExportClauseRepeat1", "export_clause_repeat1"),
        ("AmbientDeclaration", "ambient_declaration"),
        ("ExportSpecifier", "export_specifier"),
        ("CallSignature2", "call_signature"),
        ("ObjectTypeRepeat1", "object_type_repeat1"),
        ("Else", "else"),
        ("Public", "public"),
        ("TypeAnnotation", "type_annotation"),
        ("TemplateStringRepeat1", "template_string_repeat1"),
        ("Of", "of"),
        ("ForHeader", "_for_header"),
        ("InterfaceDeclaration", "interface_declaration"),
        ("VariableDeclarator", "variable_declarator"),
        ("DoStatement", "do_statement"),
        ("PrimaryType", "_primary_type"),
        ("EscapeSequence", "escape_sequence"),
        ("LTEQ", "<="),
        ("As", "as"),
        ("IntersectionType", "intersection_type"),
        ("WithStatement", "with_statement"),
        ("Protected", "protected"),
        ("This", "this"),
        ("AutomaticSemicolon", "_automatic_semicolon"),
        ("ObjectPattern", "object_pattern"),
        ("ElseClause", "else_clause"),
        ("ForInStatement", "for_in_statement"),
        ("ExtendsClause", "extends_clause"),
        ("String2", "string"),
        ("EQEQ", "=="),
        ("IndexSignature", "index_signature"),
        ("RBRACK", "]"),
        ("TypePredicateAnnotation", "type_predicate_annotation"),
        (
            "FunctionSignatureAutomaticSemicolon",
            "_function_signature_automatic_semicolon",
        ),
        ("SpreadElement", "spread_element"),
        ("StatementIdentifier", "statement_identifier"),
        ("Default", "default"),
        ("ReturnStatement", "return_statement"),
        ("ImplementsClause", "implements_clause"),
        ("SwitchStatement", "switch_statement"),
        ("DefaultType", "default_type"),
        ("ImportSpecifier", "import_specifier"),
        ("PIPEPIPE", "||"),
        ("GTGTEQ", ">>="),
        ("ClassBody", "class_body"),
        ("Number2", "number"),
        (
            "ShorthandPropertyIdentifierPattern",
            "shorthand_property_identifier_pattern",
        ),
        ("ForStatement", "for_statement"),
        ("FlowMaybeType", "flow_maybe_type"),
        ("DQUOTE", "\""),
        ("ComputedPropertyName", "computed_property_name"),
        ("SEMI", ";"),
        ("Static", "static"),
        ("TypeQuery", "type_query"),
        ("InternalModule", "internal_module"),
        ("PLUSEQ", "+="),
        ("In", "in"),
        ("COMMA", ","),
        ("Module", "module"),
        ("Require", "require"),
        ("AMPAMP", "&&"),
        ("PIPEPIPEEQ", "||="),
        ("Pair", "pair"),
        ("ContinueStatement", "continue_statement"),
        ("LTLTEQ", "<<="),
        ("Import", "import"),
        ("DestructuringPattern", "_destructuring_pattern"),
        ("AMPAMPEQ", "&&="),
        ("VariableDeclaration", "variable_declaration"),
        ("Import2", "import"),
        ("Throw", "throw"),
        ("QMARKQMARK", "??"),
        ("RegexFlags", "regex_flags"),
        ("ExportStatementRepeat1", "export_statement_repeat1"),
        ("Await", "await"),
        (
            "GeneratorFunctionDeclaration",
            "generator_function_declaration",
        ),
        ("TypeParameters", "type_parameters"),
        ("VariableDeclarationRepeat1", "variable_declaration_repeat1"),
        ("New", "new"),
        ("MappedTypeClause", "mapped_type_clause"),
        ("TemplateString", "template_string"),
        ("OptionalParameter2", "optional_parameter"),
        ("ImportClause", "import_clause"),
        ("From", "from"),
        ("Module2", "_module"),
        ("BANG", "!"),
        ("RequiredParameter2", "required_parameter"),
        ("AsExpression", "as_expression"),
        ("StatementBlock", "statement_block"),
        ("Module3", "module"),
        ("ThrowStatement", "throw_statement"),
        ("PairPattern", "pair_pattern"),
        ("Delete", "delete"),
        ("Debugger", "debugger"),
        ("ArrowFunction", "arrow_function"),
        ("LTLT", "<<"),
        ("Asserts", "asserts"),
        ("EQ", "="),
        ("ObjectRepeat1", "object_repeat1"),
        ("Target", "target"),
        ("OmittingTypeAnnotation", "omitting_type_annotation"),
        ("PropertyName", "_property_name"),
        ("AT", "@"),
        ("YieldExpression", "yield_expression"),
        ("TupleType", "tuple_type"),
        ("SQUOTE", "'"),
        ("Global", "global"),
        ("ObjectType", "object_type"),
        ("Yield", "yield"),
        ("Typeof", "typeof"),
        ("STAREQ", "*="),
        ("Private", "private"),
        ("BQUOTE", "`"),
        ("If", "if"),
        ("Function", "function"),
        ("AMPEQ", "&="),
        ("RestPattern", "rest_pattern"),
        ("Return", "return"),
        ("CARET", "^"),
        ("PERCENT", "%"),
        ("Implements", "implements"),
        ("TILDE", "~"),
        ("ImportRequireClause", "import_require_clause"),
        ("TupleTypeMember", "_tuple_type_member"),
        ("STARSTAREQ", "**="),
        ("Identifier", "identifier"),
        ("End", "end"),
        ("Try", "try"),
        ("LabeledStatement", "labeled_statement"),
        ("Super", "super"),
        ("Do", "do"),
        ("Boolean", "boolean"),
        ("NestedTypeIdentifier", "nested_type_identifier"),
        ("AMP", "&"),
        ("AugmentedAssignmentLhs", "_augmented_assignment_lhs"),
        ("Namespace", "namespace"),
        ("StringToken2", "string_token2"),
        (
            "ShorthandPropertyIdentifier",
            "shorthand_property_identifier",
        ),
        ("RequiredParameter", "required_parameter"),
        ("Function2", "function"),
        ("MemberExpression2", "member_expression"),
        ("PIPEEQ", "|="),
        ("DASHDASH", "--"),
        ("NonNullExpression", "non_null_expression"),
        ("Null", "null"),
        ("PIPE", "|"),
        ("PIPERBRACE", "|}"),
        ("BreakStatement", "break_statement"),
        ("STAR", "*"),
        ("StringRepeat2", "string_repeat2"),
        ("GeneratorFunction", "generator_function"),
        ("Declare", "declare"),
        ("Instanceof", "instanceof"),
        ("PropertyIdentifier", "property_identifier"),
        ("Get", "get"),
        ("Program", "program"),
        ("LPAREN", "("),
        ("Switch", "switch"),
        ("Array", "array"),
        ("FormalParameter", "_formal_parameter"),
        ("Type", "_type"),
        ("Error", "ERROR"),
        ("NestedIdentifier", "nested_identifier"),
        ("GTGTGTEQ", ">>>="),
        ("LBRACE", "{"),
        ("SwitchCase", "switch_case"),
        ("Catch", "catch"),
        ("Infer", "infer"),
        ("NamedImports", "named_imports"),
        ("ClassBodyRepeat1", "class_body_repeat1"),
        ("LT", "<"),
        ("Object", "object"),
        ("ObjectAssignmentPattern", "object_assignment_pattern"),
        ("EnumAssignment", "enum_assignment"),
        ("ExistentialType", "existential_type"),
        ("RBRACE", "}"),
        ("RestType", "rest_type"),
        ("Const", "const"),
        ("DOTDOTDOT", "..."),
        ("AbstractClassDeclaration", "abstract_class_declaration"),
        ("GTEQ", ">="),
        ("Type2", "type"),
        ("FunctionDeclaration", "function_declaration"),
        ("SequenceExpression", "sequence_expression"),
        ("NamespaceImport", "namespace_import"),
        ("PrimaryExpression", "primary_expression"),
        ("Declaration", "declaration"),
        ("StringToken1", "string_token1"),
        ("BANGEQ", "!="),
        ("With", "with"),
        ("GTGTGT", ">>>"),
        ("BANGEQEQ", "!=="),
        ("LexicalDeclaration", "lexical_declaration"),
        ("Constraint", "constraint"),
        ("Is", "is"),
        ("Class", "class"),
        ("CallSignature", "_call_signature"),
        ("Symbol", "symbol"),
        ("TryStatement", "try_statement"),
        ("PLUS", "+"),
        ("CallExpression2", "call_expression"),
        ("TypeParameter", "type_parameter"),
        ("LookupType", "lookup_type"),
        ("EnumBodyRepeat1", "enum_body_repeat1"),
        ("UnaryExpression", "unary_expression"),
        ("DASHQMARKCOLON", "-?:"),
        ("ObjectPatternRepeat1", "object_pattern_repeat1"),
        ("CARETEQ", "^="),
        ("SLASH2", "/"),
        ("EQEQEQ", "==="),
        ("QMARKCOLON", "?:"),
        ("ReadonlyType", "readonly_type"),
        ("ArrayPattern", "array_pattern"),
        ("ExtendsClauseRepeat1", "extends_clause_repeat1"),
        ("ClassHeritage", "class_heritage"),
        ("DOLLARLBRACE", "${"),
        ("Arguments", "arguments"),
        ("STARSTAR", "**"),
        ("False", "false"),
        ("ArrayPatternRepeat1", "array_pattern_repeat1"),
        ("ImportAlias", "import_alias"),
        ("FormalParametersRepeat1", "formal_parameters_repeat1"),
        ("PredefinedType", "predefined_type"),
        ("ImplementsClauseRepeat1", "implements_clause_repeat1"),
        ("Extends", "extends"),
        ("UnaryExpression2", "unary_expression"),
        ("MethodDefinition", "method_definition"),
        ("QMARK", "?"),
        ("WhileStatement", "while_statement"),
        ("ConstructorType", "constructor_type"),
        ("MetaProperty", "meta_property"),
        ("Void", "void"),
        ("TypeArguments", "type_arguments"),
        ("TemplateSubstitution", "template_substitution"),
        ("FunctionType", "function_type"),
        (
            "AugmentedAssignmentExpression",
            "augmented_assignment_expression",
        ),
        ("DOT", "."),
        ("EnumBody", "enum_body"),
        ("TemplateChars", "_template_chars"),
        ("OptionalType", "optional_type"),
        ("PERCENTEQ", "%="),
        ("InferType", "infer_type"),
        ("Abstract", "abstract"),
        ("PublicFieldDefinition", "public_field_definition"),
        ("GenericType", "generic_type"),
        ("Class2", "class"),
        ("For", "for"),
        ("ArrayRepeat1", "array_repeat1"),
        ("Enum", "enum"),
        ("IfStatement", "if_statement"),
        ("TernaryExpression", "ternary_expression"),
        ("SwitchDefault", "switch_default"),
        ("EmptyStatement", "empty_statement"),
        ("ConstructSignature", "construct_signature"),
        ("AbstractMethodSignature", "abstract_method_signature"),
        ("TupleTypeRepeat1", "tuple_type_repeat1"),
        ("DebuggerStatement", "debugger_statement"),
    ]),
};

impl From<Typescript> for &str {
    #[inline(always)]
    fn from(grammar: Typescript) -> &'static str {
        KEYS.get(grammar.to_string().as_str()).unwrap()
    }
}

impl From<u16> for Typescript {
    #[inline(always)]
    fn from(x: u16) -> Self {
        num::FromPrimitive::from_u16(x).unwrap_or(Self::Error)
    }
}

// Typescript == u16
impl PartialEq<u16> for Typescript {
    #[inline(always)]
    fn eq(&self, x: &u16) -> bool {
        *self == Typescript::from(*x)
    }
}

// u16 == Typescript
impl PartialEq<Typescript> for u16 {
    #[inline(always)]
    fn eq(&self, x: &Typescript) -> bool {
        *x == *self
    }
}
